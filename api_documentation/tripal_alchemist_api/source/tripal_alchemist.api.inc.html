<html>
    <head>
        <script
            type="text/javascript"
            src="../js/jquery-1.4.2.min.js">
        </script>
        <script
            type="text/javascript"
            src="../syntax_highlighter/scripts/shCore.js">
        </script>
        <script
            type="text/javascript"
            src="../syntax_highlighter/scripts/shBrushJScript.js">
        </script>
        <script
            type="text/javascript"
            src="../syntax_highlighter/scripts/shBrushPhp.js">
        </script>
        <script
            type="text/javascript"
            src="../syntax_highlighter/scripts/shBrushXml.js">
        </script>
        <link
            href="../syntax_highlighter/styles/shCore.css" rel="stylesheet"
            type="text/css"
        />
        <link
            href="../syntax_highlighter/styles/shCoreEclipse.css"
            rel="stylesheet" type="text/css"
        />
        <link
            href="../syntax_highlighter/styles/shThemeWordpress.css"
            rel="stylesheet" type="text/css"
        />
    </head>
    <body>
        <pre class="brush: php">&lt;?php

/**
 *   Returns an array of all bundle objects.
 *
 * @return array|bool
 *
 * @ingroup General_entities
 */
function tripal_alchemist_get_all_bundles() {

  $bundles = [];

  // Get all bundle names to cycle through.
  $all_bundles = db_select('tripal_bundle', 'tb')
    -&gt;fields('tb', ['name'])
    -&gt;execute()
    -&gt;fetchAll();

  foreach ($all_bundles as $bundle_name) {
    // Get the bundle object.
    $bundle = tripal_load_bundle_entity(['name' =&gt; $bundle_name-&gt;name]);
    if (!$bundle) {
      tripal_report_error('tripal', TRIPAL_ERROR, &quot;Unrecognized bundle name '%bundle'.&quot;,
        ['%bundle' =&gt; $bundle_name]);
      return FALSE;
    }

    array_push($bundles, $bundle);
  }

  return $bundles;
}


/**
 * Get bundles that map to a particular source table.
 *
 * @param $source_table
 *
 * @return array
 *
 * @ingroup General_entities
 */

function tripal_alchemist_get_matching_bundles($source_table) {
  $options = [];
  $all_bundles_object = tripal_alchemist_get_all_bundles();
  foreach ($all_bundles_object as $bundle) {
    if ($bundle-&gt;data_table == $source_table) {
      $options[$bundle-&gt;id] = $bundle-&gt;label;
    }
  }
  return ($options);
}

/**
 * Convert all entities from one bundle type to another
 *
 *
 * @param $args  An array with teh following keys:
 * 'source_bundle' =&gt; the source bundle.  All entities in the source will be converted.
 * 'destination_bundle' =&gt; The destination bundle.
 *
 * @ingroup Convert_entities
 */

function tripal_alchemist_convert_all_entities($args) {
  $source_bundle = $args['source_bundle'];
  $destination_bundle = $args['destination_bundle'];
  $source_bundle_table = &quot;public.chado_&quot; . $source_bundle-&gt;name;
  $destination_term = $destination_bundle-&gt;term_id;
  $destination_table = &quot;public.chado_&quot; . $destination_bundle-&gt;name;
  $chado_base_table = &quot;chado.&quot; . $source_bundle-&gt;data_table;
  $chado_prop_table = $chado_base_table . &quot;prop&quot;;

  $type_id = $destination_bundle-&gt;type_id;
  $type_column = $destination_bundle-&gt;type_column;
  $descriminating_prop_value = $destination_bundle-&gt;type_value;
  $descriminating_type_cvterm_id = $destination_bundle-&gt;type_id;


  //TODO:  add any hard-coded exceptions here since we guess the primary record column
  $base_record_column = $source_bundle-&gt;data_table . &quot;_id&quot;;

  if (!$source_bundle || !$destination_bundle) {
    tripal_set_message(&quot;Error: Destination and source bundle not provided.  Cannot convert entities without source and destination bundles.&quot;, TRIPAL_ERROR);
  }

  $type_linker_table = NULL;

  if (!$destination_bundle-&gt;type_linker_table &amp;&amp; $destination_bundle-&gt;type_column) {

    //step 1 get all qualifying entities

    $query = db_select($chado_base_table, 'CBT');
    $query-&gt;fields('SET', ['entity_id', 'record_id']);
    $query-&gt;innerJoin($source_bundle_table, 'SET', 'SET.record_id = CBT.' . $source_bundle-&gt;data_table . '_id');
    $query-&gt;leftJoin($destination_table, 'DET', 'SET.record_id = DET.record_id');
    $query-&gt;condition('CBT.' . $type_column, $type_id);
    $query-&gt;condition('DET.record_id', NULL, 'IS');
    $results = $query-&gt;execute()-&gt;fetchAll();

    foreach ($results as $result) {
      $record_id = $result-&gt;record_id;
      $entity_id = $result-&gt;entity_id;

      if (!$record_id) {
        tripal_report_error(&quot;Could not retrieve record id for entity $entity_id.  Aborting.&quot;, TRIPAL_ERROR);
      }

      //insert into the destination table
      //TODO Ignore duplicates
      try {
        $result = db_insert($destination_table)
          -&gt;fields(['entity_id' =&gt; $entity_id, 'record_id' =&gt; $record_id])
          -&gt;execute();
      } catch (Exception $e) {
      }

      //update the tripal entity table
      $result = db_update(&quot;public.tripal_entity&quot;)
        -&gt;fields([
          'bundle' =&gt; $destination_bundle-&gt;name,
          'term_id' =&gt; $destination_term,
        ])
        -&gt;condition('id', $entity_id, '=')
        -&gt;execute();

      // Delete the old entities, but only if they are present in the destination table
      //delete from source
      //TODO: CHECK THAT IT WAS SUCCESSFUL BEFORE DELETING
      $result = db_delete($source_bundle_table)
        -&gt;condition('entity_id', $entity_id)
        -&gt;condition('record_id', $record_id)
        -&gt;execute();
    }

    return;
  }

  //Setting a type_id column in a linker table.

  //Need to use query builder instead
  //on conflict will ignore duplicate insert attempts from, say, migrating 2x and resulting in duplicate id's

  //TODO:  UPDATE THIS TO MODERN QUERY BUILDER
  //copy the entity over from source to destination
  $sql = &quot;INSERT INTO &quot; . db_escape_table($destination_table) . &quot; (entity_id, record_id)
          (SELECT AB.entity_id AS entity_id, AB.record_id AS record_id FROM &quot; . db_escape_table($chado_base_table) . &quot;  A
          INNER JOIN  &quot; . db_escape_table($chado_prop_table) . &quot; AP  ON A.&quot; . db_escape_field($base_record_column) . &quot; = AP. &quot; . db_escape_field($base_record_column) . &quot;
          INNER JOIN chado.cvterm CVT ON AP.&quot; . db_escape_field($type_column) . &quot; = CVT.cvterm_id
          INNER JOIN  &quot; . db_escape_table($source_bundle_table) . &quot; AB ON A.&quot; . ($base_record_column) . &quot; = AB.record_id
          LEFT JOIN  &quot; . db_escape_table($destination_table) . &quot; DT ON A.&quot; . db_escape_field($base_record_column) . &quot; = DT.record_id
          WHERE CVT.cvterm_id = :cvterm_id 
            AND AP.value = :descrim_prop_value 
            AND DT.record_id IS NULL)&quot;;

  $results = db_query($sql, [
    &quot;:cvterm_id&quot; =&gt; $descriminating_type_cvterm_id,
    &quot;:descrim_prop_value&quot; =&gt; $descriminating_prop_value,
  ]);

  //Update the tripal_entity table

  $sql = &quot;UPDATE public.tripal_entity AS TE SET bundle = :destination_bundle, term_id = :destination_term
WHERE TE.id  IN (SELECT AB.entity_id AS entity_id FROM &quot; . $chado_base_table . &quot; A
INNER JOIN  &quot; . $chado_prop_table . &quot; AP  ON A.&quot; . db_escape_field($base_record_column) . &quot; = AP. &quot; . db_escape_field($base_record_column) . &quot;
INNER JOIN chado.cvterm CVT ON AP.&quot; . db_escape_field($type_column) . &quot; = CVT.cvterm_id
INNER JOIN  &quot; . $source_bundle_table . &quot; AB ON A.&quot; . db_escape_field($base_record_column) . &quot; = AB.record_id
WHERE CVT.cvterm_id = :cvterm_id
AND AP.value = :descrim_prop_value )&quot;;

  $params = [
    &quot;:cvterm_id&quot; =&gt; $descriminating_type_cvterm_id,
    &quot;:descrim_prop_value&quot; =&gt; $descriminating_prop_value,
    ':destination_term' =&gt; $destination_term,
    &quot;:destination_bundle&quot; =&gt; $destination_bundle-&gt;name,
  ];

  $results = db_query($sql, $params);

  // Delete the old entities, but only if they are present in the destination table
  $sql = &quot;DELETE FROM &quot; . $source_bundle_table . &quot; AB
WHERE AB.record_id IN
(SELECT A.analysis_id AS record_id
FROM &quot; . $chado_base_table . &quot; A
INNER JOIN &quot; . $chado_prop_table . &quot; AP ON  A.&quot; . db_escape_field($base_record_column) . &quot; = AP. &quot; . db_escape_field($base_record_column) . &quot;
INNER JOIN chado.cvterm CVT ON AP.type_id = CVT.cvterm_id
INNER JOIN &quot; . $destination_table . &quot; AS DT ON AB.record_id = DT.record_id
WHERE CVT.cvterm_id = :cvterm_id
AND AP.value = :descrim_prop_value)&quot;;

  $results = db_query($sql, [
    &quot;:cvterm_id&quot; =&gt; $descriminating_type_cvterm_id,
    &quot;:descrim_prop_value&quot; =&gt; $descriminating_prop_value,
  ]);
}


/**
 * Converts a select list of entities.
 *
 * This list of entities is retrieved either as a list of entity ids, or via a collection, depending on the args passed in.
 *
 * @param $args
 * An array with the following keys:
 * 'source_bundle'
 * 'destination_bundle'
 * 'source_entities'
 * 'collection'
 *
 * @ingroup Convert_entities
 */


function tripal_alchemist_convert_select_entities($args) {

  $source_bundle = $args['source_bundle'];
  $destination_bundle = $args['destination_bundle'];
  $source_entities = isset($args['source_entities']) ? $args['source_entities'] : null;

  $collection = isset($args['collection']) ? $args['collection'] : null;

  if (!$source_bundle || !$destination_bundle) {
    tripal_set_message(&quot;Error: Destination and source bundle not provided.  Cannot convert entities without source and destination bundles.&quot;, TRIPAL_ERROR);
    return;
  }
  if ($source_bundle-&gt;data_table != $destination_bundle-&gt;data_table) {
    tripal_set_message(&quot;Error: destination and source bundles do not have the same base table.&quot;, TRIPAL_ERROR);
    return;
  }
  if ($collection) {
    //get entities
    $source_entities = tripal_alchemist_get_eligible_entities($collection, $source_bundle);
  }

  if (!$source_entities) {
    tripal_set_message(&quot;Error: No qualifying source entities.&quot;, TRIPAL_ERROR);
    return;
  }
  //get all our source and destination table info
  $descriminating_type_cvterm_id = $destination_bundle-&gt;type_id;
  $descriminating_prop_value = $destination_bundle-&gt;type_value;
  $type_column = $destination_bundle-&gt;type_column;
  $source_bundle_table = &quot;public.chado_&quot; . $source_bundle-&gt;name;
  $destination_term = $destination_bundle-&gt;term_id;
  $destination_table = &quot;public.chado_&quot; . $destination_bundle-&gt;name;
  $chado_base_table = &quot;chado.&quot; . $source_bundle-&gt;data_table;
  $chado_prop_table = $chado_base_table . &quot;prop&quot;;

  //TODO:  add any hard-coded exceptions here since we guess the primary record column
  $base_record_column = $source_bundle-&gt;data_table . &quot;_id&quot;;
  $linker_type = &quot;table&quot;;

  if (!$destination_bundle-&gt;type_linker_table &amp;&amp; $destination_bundle-&gt;type_column) {
    $linker_type = &quot;column&quot;;
  }
  //First, set the property in Chado for each selected record.

  $entity_to_record = [];

  $chado_entity_table = chado_get_bundle_entity_table($source_bundle);

  foreach ($source_entities as $entity_id) {
    $record_id = db_select($chado_entity_table, 'CE')
      -&gt;fields('CE', ['record_id'])
      -&gt;condition('CE.entity_id', $entity_id)
      -&gt;execute()
      -&gt;fetchField();

    if (!$record_id) {
      tripal_report_error(&quot;Could not retrieve record id for entity $entity_id.  Aborting.&quot;, TRIPAL_ERROR);
    }

    //first update property
    if ($linker_type === &quot;column&quot;) {
      //type column.

      $result = db_update($chado_base_table)
        -&gt;fields([
          $type_column =&gt; $descriminating_type_cvterm_id,
        ])
        -&gt;condition($source_bundle-&gt;data_table . '_id', $record_id, '=')
        -&gt;execute();

    }
    else {
      //linker column
      $record = ['table' =&gt; $source_bundle-&gt;data_table, 'id' =&gt; $record_id];
      $property = [
        $type_column =&gt; $descriminating_type_cvterm_id,
        'value' =&gt; $descriminating_prop_value,
      ];

      $options = ['update_if_present' =&gt; TRUE];
      if (!chado_insert_property($record, $property, $options)) {
        tripal_report_error(&quot;Tripal_alchemist&quot;, TRIPAL_ERROR, &quot;Could not update property for entity $entity_id.  Aborting.&quot;);
        return;
      }
    }
    //insert into the destination table
    try {
      $result = db_insert($destination_table)
        -&gt;fields(['entity_id' =&gt; $entity_id, 'record_id' =&gt; $record_id])
        -&gt;execute();
    } catch (Exception $e) {
    }
    //update the tripal entity table
    $result = db_update(&quot;public.tripal_entity&quot;)
      -&gt;fields([
        'bundle' =&gt; $destination_bundle-&gt;name,
        'term_id' =&gt; $destination_term,
      ])
      -&gt;condition('id', $entity_id, '=')
      -&gt;execute();
    //delete from source
    //TODO: CHECK THAT IT WAS SUCCESSFUL BEFORE DELETING
    $result = db_delete($source_bundle_table)
      -&gt;condition('entity_id', $entity_id)
      -&gt;condition('record_id', $record_id)
      -&gt;execute();
  }
}


/**
 * Given a bundle object, count the number of entries for that bundle.
 *
 * @param $bundle
 *
 * @return mixed
 *
 * @ingroup General_entities
 */

function tripal_alchemist_fetch_current_bundle_entities($bundle) {

  $sql = &quot;SELECT COUNT(*) FROM public.chado_&quot; . $bundle-&gt;name;
  $results = db_query($sql)-&gt;fetchObject();
  return ($results-&gt;count);
}


/**
 * Given the bundle ID, fetch the bundle name and label
 * @param $bundle_id
 *
 * @return mixed
 * @ingroup General_entities
 */
function function_tripal_alchemist_get_bundle($bundle_id) {


  $query = &quot;SELECT TB.name, TB.label FROM public.tripal_bundle TB WHERE TB.id = :bundle_id&quot;;
  $result = db_query($query, [':bundle_id' =&gt; $bundle_id])-&gt;fetchObject();
  return $result;
}


/**
 * Given a collection object, return all entities in the collection from the source bundle.
 *
 * @param $collection
 * @param $source_bundle
 *
 * @return array
 *
 *  @ingroup Convert_entities

 */

function tripal_alchemist_get_eligible_entities($collection, $source_bundle){
  $entities = $collection-&gt;getEntityIDs();

  $matching_entities = [];
  foreach ($entities as $entity) {
    $source_entity_table = &quot;public.chado_&quot; . $source_bundle-&gt;name; //SET SOURCE ENTITY TABLE
    $query = db_select($source_entity_table, 'SET')
      -&gt;condition('SET.entity_id', $entity, &quot;=&quot;);
    $result = $query-&gt;execute()-&gt;fetchAll();
    if ($result) {
      $matching_entities[] = $entity;
    }
  }

  return($matching_entities);
}</pre>
        <script type="text/javascript">
             SyntaxHighlighter.all();
             jQuery('.gutter div').each(function(key, data){
                jQuery(data).prepend('<a name="L'+jQuery(data).text()+'"/>');
             });
        </script>
    </body>
</html>